// RobotBuilder Version: 6.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: RobotContainer.

package frc.robot;

import frc.robot.commands.*;
import frc.robot.subsystems.*;
import edu.wpi.first.hal.AllianceStationID;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.GenericHID;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.DriverStation.Alliance;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.util.Color;
import edu.wpi.first.wpilibj2.command.Command.InterruptionBehavior;
import edu.wpi.first.wpilibj2.command.button.JoystickButton;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.Commands;
import edu.wpi.first.wpilibj2.command.ConditionalCommand;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.ParallelCommandGroup;
import edu.wpi.first.wpilibj2.command.RunCommand;
import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import edu.wpi.first.wpilibj2.command.WaitCommand;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 * This class is where the bulk of the robot should be declared.  Since Command-based is a
 * "declarative" paradigm, very little robot logic should actually be handled in the {@link Robot}
 * periodic methods (other than the scheduler calls).  Instead, the structure of the robot
 * (including subsystems, commands, and button mappings) should be declared here.
 */
public class RobotContainer {

  private static RobotContainer m_robotContainer = new RobotContainer();

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
// The robot's subsystems
    public final DriveTrain m_drivetrain = new DriveTrain();
    public final Climber m_climber = new Climber();
    public final Shooter m_shooter = new Shooter();
    public final Feeder m_feeder = new Feeder();
    public final Claw m_claw = new Claw();

    public final Joystick joystick = new Joystick(0);
    public final XboxController xbox = new XboxController(1);


// Joysticks

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

  
  // A chooser for autonomous commands
  SendableChooser<Command> m_chooser = new SendableChooser<>();

      final Command UnshootNote = new ParallelCommandGroup(
      //run both shooter motors in reverse to intake
      m_shooter.PrepareShooter(-.4),
      m_feeder.RunFeedMotor(-.6)
    );

     final Command ShootNote = new ParallelCommandGroup(
       //run shooter motor to get to max speed, then feed note into shooter motor
       m_shooter.PrepareShooter(1),
       new WaitCommand(1.5).andThen(m_feeder.RunFeedMotor(1))
     );

     final Command Winch = new ConditionalCommand(
      m_climber.MoveWinch(.5), 
      m_climber.MoveWinch(0), 
      ()->SmartDashboard.getBoolean("ifWinchEnabled", true)
      );

     final Command AutoSpeaker = new SequentialCommandGroup(
           new ParallelCommandGroup(
           //run shooter motor to get to max speed, then feed note into shooter motor
           m_shooter.PrepareShooter(1),
           new WaitCommand(1.5).andThen(m_feeder.RunFeedMotor(1))
          ).raceWith(new WaitCommand(3)),
       new DefaultDrive(m_drivetrain, .5, 0).raceWith(new WaitCommand(3)),
       new DefaultDrive(m_drivetrain, 0, 0)
     );

    final Command AutoTaxi = new SequentialCommandGroup(
       new DefaultDrive(m_drivetrain, .5, 0).raceWith(new WaitCommand(3)),
       new DefaultDrive(m_drivetrain, 0, 0)
     );
     
    
  //   // Variable alliance used to determine the multiplier for the autoamp command
  //   public int getAutonomousColortheSecond() {
  //     // alliance default value = 1
  //     int alliance = 1;
  //   if(DriverStation.getAlliance().get() == Alliance.Blue){
  //     // Multiplies to -1 when detects the blue alliance
  //     alliance *= -1;
  //   }
  //   return alliance;
  // }
  //   final Command theSecondAutoAmp = new SequentialCommandGroup(
  //     new DefaultDrive(m_drivetrain, -.5, 0).raceWith(new WaitCommand(1)),
  //     new Rotate(m_drivetrain, (getAutonomousColortheSecond()), m_drivetrain.getGyro()),
  //     new DefaultDrive(m_drivetrain, -.5, 0).raceWith(new WaitCommand(1)),
  //     m_claw.MoveClaw(.4),
  //     new DefaultDrive(m_drivetrain, .5, 0).raceWith(new WaitCommand(1)),
  //     new Rotate(m_drivetrain, (getAutonomousColortheSecond()), m_drivetrain.getGyro()),
  //     new DefaultDrive(m_drivetrain, -.5, 0).raceWith(new WaitCommand(1))
  //    );


     
      public Command AutoAmpRed = new SequentialCommandGroup(
      // starts on line
      // drive straight ~24"
      // turn right 90 degrees
      // drive forward into amp ~20"
      // claw out
      // drive backwards ~24-30"
      // turn left 90 degrees
      // drive forward to leave starting area ~10-15'
//TODO TWEAK TIMES AND VALUES, PLACEHOLDER ONLY
      new DefaultDrive(m_drivetrain, -.5, 0).raceWith(new WaitCommand(1.2)),
        new DefaultDrive(m_drivetrain, 0, 0).raceWith(new WaitCommand(.01)),
      new Rotate(m_drivetrain, -1, m_drivetrain.getGyro()).until(()->SmartDashboard.getNumber("Gyro Yaw", 0) > 65),
//change back to 1 sec
      new DefaultDrive(m_drivetrain, -.5, 0).raceWith(new WaitCommand(.5)),
        new DefaultDrive(m_drivetrain, 0, 0).raceWith(new WaitCommand(.01)),
      new WaitCommand(1).andThen(m_claw.MoveClaw(.4).raceWith(new WaitCommand(1))),
//change back to 1.2 sec
      new DefaultDrive(m_drivetrain, .5, 0).raceWith(new WaitCommand(.5)),
        new DefaultDrive(m_drivetrain, 0, 0).raceWith(new WaitCommand(.01)),
      new Rotate(m_drivetrain, 1, m_drivetrain.getGyro()).until(()->SmartDashboard.getNumber("Gyro Yaw", 0) < 25),
      new DefaultDrive(m_drivetrain, -.5, 0).raceWith(new WaitCommand(1)),
        new DefaultDrive(m_drivetrain, 0, 0).raceWith(new WaitCommand(.01))
     );

     public Command AutoAmpBlue = new SequentialCommandGroup(
      new DefaultDrive(m_drivetrain, -.5, 0).raceWith(new WaitCommand(1.2)),
        new DefaultDrive(m_drivetrain, 0, 0).raceWith(new WaitCommand(.01)),
      new Rotate(m_drivetrain, 1, m_drivetrain.getGyro()).until(()->SmartDashboard.getNumber("Gyro Yaw", 0) < -65),
//change back to 1 sec
      new DefaultDrive(m_drivetrain, -.5, 0).raceWith(new WaitCommand(.5)),
        new DefaultDrive(m_drivetrain, 0, 0).raceWith(new WaitCommand(.01)),
      new WaitCommand(1).andThen(m_claw.MoveClaw(.4).raceWith(new WaitCommand(1))),
//change back to 1.2 sec
      new DefaultDrive(m_drivetrain, .5, 0).raceWith(new WaitCommand(.5)),
        new DefaultDrive(m_drivetrain, 0, 0).raceWith(new WaitCommand(.01)),
//TODO - NOT TURNING SECOND TIME FOR SOME REASON
      new Rotate(m_drivetrain, -1, m_drivetrain.getGyro()).until(()->SmartDashboard.getNumber("Gyro Yaw", 0) > -25),
      new DefaultDrive(m_drivetrain, -.5, 0).raceWith(new WaitCommand(1)),
        new DefaultDrive(m_drivetrain, 0, 0).raceWith(new WaitCommand(.01))
     );

      public Command AutoAmp = getAutonomousColor();

      public Command DoNothing;

     //for blue, just switch rotation commands

  /**
  * The container for the robot.  Contains subsystems, OI devices, and commands.
  */
  private RobotContainer() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SMARTDASHBOARD
    // Smartdashboard Subsystems


    // SmartDashboard Buttons
    //SmartDashboard.putData("Autonomous Command", new AutonomousCommand());

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SMARTDASHBOARD
    // Configure the button bindings
    configureButtonBindings();

    SmartDashboard.putBoolean("ifWinchEnabled", true);
    SmartDashboard.putNumber("climbEncoder", 0);
    SmartDashboard.putString("Alliance Color", "N/A");
    SmartDashboard.putBoolean("Limelight Enabled", false);

    // Configure default commands
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SUBSYSTEM_DEFAULT_COMMAND


        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SUBSYSTEM_DEFAULT_COMMAND

    // Configure autonomous sendable chooser
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

    m_chooser.setDefaultOption("Auto Speaker", AutoSpeaker);
    m_chooser.addOption("Auto Taxi (No Shoot)", AutoTaxi);
    m_chooser.addOption("Auto Amp (Red)", AutoAmpRed);
    m_chooser.addOption("Auto Amp (Blue)", AutoAmpBlue);
    //change back to autoamp
    // m_chooser.addOption("The Better AutoAmp", theSecondAutoAmp);
    m_chooser.addOption("Last Resort", DoNothing);


    m_drivetrain.setDefaultCommand(

    new DefaultDrive(m_drivetrain)
    //new TankDrive(m_drivetrain)

    );



        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

    SmartDashboard.putData("Auto Mode", m_chooser);
  }

  private Command getAutonomousColor() {
    if(DriverStation.getAlliance().get() == Alliance.Red){
      SmartDashboard.putString("Alliance Color", "Red");
      return AutoAmpRed;
    }else if(DriverStation.getAlliance().get() == Alliance.Blue){
      SmartDashboard.putString("Alliance Color", "Blue");
      return AutoAmpBlue;
    }
      return AutoTaxi;
  }

  public static RobotContainer getInstance() {
    return m_robotContainer;
  }

  /**
   * Use this method to define your button->command mappings.  Buttons can be created by
   * instantiating a {@link GenericHID} or one of its subclasses ({@link
   * edu.wpi.first.wpilibj.Joystick} or {@link XboxController}), and then passing it to a
   * {@link edu.wpi.first.wpilibj2.command.button.JoystickButton}.
   */
  private void configureButtonBindings() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=BUTTONS
// Create some buttons

      final JoystickButton shootButton = new JoystickButton(xbox, 5);
      shootButton.onTrue(ShootNote);

      final JoystickButton unshootButton = new JoystickButton(xbox, 6);
      unshootButton.whileTrue(UnshootNote);

      final JoystickButton clawIntake = new JoystickButton(xbox, 2);
      clawIntake.whileTrue(m_claw.MoveClaw(-.4));

      final JoystickButton clawOuttake = new JoystickButton(xbox, 3);
      clawOuttake.whileTrue(m_claw.MoveClaw(.4));
      //clawOuttake.whileTrue(new DefaultDrive(m_drivetrain, true));

      // final JoystickButton winchUp = new JoystickButton(xbox, 4);
      // winchUp.whileTrue(m_climber.MoveWinch(.5));

      final JoystickButton winchDown = new JoystickButton(xbox, 1);
      winchDown.whileTrue(Winch); 
      
      final JoystickButton limelightDrive = new JoystickButton(joystick, 1);
      limelightDrive.whileTrue(m_drivetrain.LimelightTrigger());

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=BUTTONS
  }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS

  /**
   * Use this to pass the autonomous command to the main {@link Robot} class.
   *
   * @return the command to run in autonomous
  */
  public Command getAutonomousCommand() {
    // The selected command will be run in autonomous
    return m_chooser.getSelected();
  }

  public Joystick getJoystick(){
    return joystick;
  }

  public Command getShootNoteCommand(){
    return ShootNote;
  }
  

}

